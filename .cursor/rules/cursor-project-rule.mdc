---
alwaysApply: true
---
# Cursor Project Rule

**Applies to:** this repository and all Cursor-generated changes.

## Purpose

Guarantee every feature is designed and implemented using the official references for:

* **Vercel AI SDK V5 (Core)** — `https://ai-sdk.dev/docs/introduction`
* **AI Elements** — `https://ai-sdk.dev/elements/overview`
* **Vercel AI Gateway** — `https://vercel.com/docs/ai-gateway`
* **Supabase (Backend & Storage/Auth/DB/Edge Functions)** — `https://supabase.com/docs`

## Non‑negotiable Rules

1. **Always consult docs first.** Before writing code or UI, read the relevant sections of the four docs above. Prefer the **latest, canonical examples** from these pages.
2. **Cite sources inline.** In every PR description and major file header, include a short “References” block with exact doc section URLs used for that change.
3. **Use the official patterns.**

   * AI calls must use **Vercel AI SDK V5 (Core)** idioms (streaming, tool calling, providers) and **AI Gateway** for routing/observability.
   * UI must use **AI Elements** components when building chat/assistants, rather than custom re‑implementations.
   * All backend data, auth, storage, RLS, and edge functions must use **Supabase** clients and recommended patterns.
4. **No ad‑hoc providers or unvetted libs.** If a feature needs a new model/provider, it must go through AI Gateway and follow AI SDK docs.
5. **Type safety & envs.** Strong TypeScript types, zod (or equivalent) for I/O boundaries, and `env` variables managed via `.env.local` with typed access.
6. This project must use **Vercel AI SDK V5 versioning ONLY. DO NOT USE LOWER VERSIONS.
7. This will be build in vercel se pay attention to potential typescripts errors and eslint errors.


Vercel builds must never fail due to ESLint.

Cursor must avoid any by default and generate proper, narrow types.

Linting remains useful locally/CI without blocking deploys.

Apply this rule to all new and edited files.

Build behavior (must be enforced)

Next config: skip ESLint during next build

If next.config.{js,ts} exists, ensure:

/** @type {import('next').NextConfig} */
const nextConfig = { eslint: { ignoreDuringBuilds: true } };
module.exports = nextConfig;


If config already exists, merge (do not overwrite unrelated settings).

ESLint config (guardrail, not blocker)

Ensure .eslintrc.json contains:

{
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-imports": "error",
    "no-restricted-syntax": [
      "warn",
      { "selector": "TSTypeReference[typeName.name='any']", "message": "Do not use 'any' types." }
    ]
  }
}


Never weaken other rules unless required by Next.

Scripts

Ensure package.json has:

{
  "scripts": {
    "lint": "next lint",
    "lint:strict": "next lint --max-warnings=0",
    "typecheck": "tsc --noEmit"
  }
}


TypeScript strictness

Ensure tsconfig.json includes:

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true
  }
}


Ignore noisy/generated paths

Ensure .eslintignore includes:

node_modules
.next
dist
public
**/generated/**
**/*.d.ts

Authoring code (Cursor must follow)

Never introduce any. Prefer concrete types, unknown + narrowing, or Record<string, unknown>.

Always type:

React handlers: React.ChangeEvent<HTMLInputElement|HTMLTextAreaElement|HTMLSelectElement>

Next API: NextRequest / NextResponse

Fetch JSON: unknown then narrow before use.

Create/reuse minimal interfaces for SDKs (e.g., Facebook/Meta) under src/types/ and import them instead of any.

Required patterns
// Good: fetch + narrowing
const json: unknown = await fetch(url).then(r => r.json());
function isMe(x: unknown): x is { id: string; name?: string } {
  return typeof x === "object" && x !== null && typeof (x as any).id === "string";
}
if (isMe(json)) {
  const { id } = json;
}

// Good: event typing
function onChange(e: React.ChangeEvent<HTMLInputElement>) {
  setValue(e.target.value);
}

// Good: generic objects
type Dict = Record<string, unknown>;

Types scaffold (auto-create if missing)

Create src/types/common.ts with:

export type Dict = Record<string, unknown>;

export interface FbMe { id: string; name?: string }
export interface FbToken { access_token: string; token_type?: string; expires_in?: number }

// Add feature-specific types nearby to usage files, then re-export here for reuse.

Local/CI policy (optional but recommended)

Run npm run typecheck && npm run lint locally.

In CI, use npm run lint:strict to fail on warnings if you want zero-tolerance, but Vercel builds must not fail due to ESLint because ignoreDuringBuilds=true.

File/line exceptions (rare)

If an SDK/shim truly requires any, use a single-line suppression with a comment why:

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- SDK callback has polymorphic shape we don't control
function shim(x: any) { /* ... */ }


Avoid file-wide disables.

Ready-to-paste configs (if you want them now)

next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: { ignoreDuringBuilds: true },
};
module.exports = nextConfig;


.eslintrc.json

{
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-imports": "error",
    "no-restricted-syntax": [
      "warn",
      { "selector": "TSTypeReference[typeName.name='any']", "message": "Do not use 'any' types." }
    ]
  }
}


tsconfig.json (partial)

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true
  }
}


.eslintignore

node_modules
.next
dist
public
**/generated/**
**/*.d.ts

## Definition of Done (per task)

* [ ] **Design note** links to the exact doc sections used.
* [ ] **API client** created/updated using AI SDK Core examples.
* [ ] **UI** built with AI Elements where applicable.
* [ ] **AI Gateway** config added (routes/keys/observability) as per docs.
* [ ] **Supabase**: schema, RLS, auth flow, and queries implemented by copying/adapting official examples.
* [ ] **References** block in PR (copy/paste template below).
* [ ] **Smoke test** steps included.

## File Header Template (paste at top of new/edited files)

```md
/**
 * Feature: <short title>
 * Purpose: <what this file does>
 * References:
 *  - AI SDK Core: https://ai-sdk.dev/docs/introduction#<section>
 *  - AI Elements: https://ai-sdk.dev/elements/overview#<section>
 *  - Vercel AI Gateway: https://vercel.com/docs/ai-gateway#<section>
 *  - Supabase: https://supabase.com/docs/<product>/<section>
 */
```

## PR Description Template

```
### What & Why
<1–3 sentences>

### Implementation Notes
- Followed AI SDK Core pattern for <streaming/tool calling/etc>.
- Used AI Elements <ComponentName> for <chat/input/history>.
- Routed model traffic via AI Gateway <config link/notes>.
- Supabase <auth/storage/db> per docs <links>.

### References
- AI SDK Core: <exact section URL>
- AI Elements: <exact section URL>
- AI Gateway: <exact section URL>
- Supabase: <exact section URL>

### Test Plan
1) <steps>
2) <expected output>
```

## Enforcement

* Cursor: Always expand the **References** block before proposing code.
* If a suggestion contradicts the linked docs, prefer the docs and note the discrepancy.
* When docs show multiple options, choose the simplest **official** path first.
* Cursor has access to Supabase via MCP, so it can execute/check on behalf of us instead of asking.

## Quick Links

* AI SDK Core — [https://ai-sdk.dev/docs/introduction](https://ai-sdk.dev/docs/introduction)
* AI Elements — [https://ai-sdk.dev/elements/overview](https://ai-sdk.dev/elements/overview)
* Vercel AI Gateway — [https://vercel.com/docs/ai-gateway](https://vercel.com/docs/ai-gateway)
* Supabase — [https://supabase.com/docs](https://supabase.com/docs)
